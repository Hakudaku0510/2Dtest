<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>どんどん広がるマップ探検｜無限生成版</title>
  <style>
    :root { --bg:#0b1020; --fg:#e6e8ef; --accent:#7dd3fc; --accent2:#a78bfa; --danger:#ef4444; }
    html,body { height:100%; }
    body { margin:0; background:var(--bg); color:var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; display:grid; place-items:center; }
    .wrap { width:min(100vw,1100px); padding:16px; }
    .card { background:#111832; border:1px solid #26314f; border-radius:16px; padding:12px; box-shadow:0 12px 30px rgba(0,0,0,.25); }
    #game { display:block; width:100%; height:auto; border-radius:12px; image-rendering: pixelated; background:#0a0f1f; outline:1px solid #223055; }
    .hud { display:flex; flex-wrap:wrap; justify-content:space-between; gap:12px; align-items:center; margin-top:8px; font-size:14px; color:#c7d2fe; }
    .hud .pill { background:#0f1530; border:1px solid #27305a; border-radius:999px; padding:6px 10px; }
    .hud .right { display:flex; gap:8px; align-items:center; }
    .msg { margin-top:8px; min-height:20px; color:#a7f3d0; font-size:14px; white-space:pre-wrap; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; background:#0c1228; border:1px solid #253163; border-bottom-width:2px; padding:2px 6px; border-radius:6px; }
    .footer { margin-top:8px; font-size:12px; color:#93c5fd; opacity:.9; }
  </style>
</head>
<body>
  <div class="wrap card">
    <canvas id="game" width="960" height="540"></canvas>
    <div class="hud">
      <div class="pill">操作: <span class="kbd">←→/A D</span> 移動、<span class="kbd">Z/Space</span> ジャンプ、<span class="kbd">R</span> リスポーン</div>
      <div class="right">
        <div class="pill" id="dist">距離: 0m</div>
        <div class="pill" id="score">★ 0</div>
        <div class="pill" id="hp">HP: ❤❤❤</div>
      </div>
    </div>
    <div class="msg" id="msg"></div>
    <div class="footer">無限に続くステージを自動生成。青いオーブ（★）でスコア、旗でチェックポイント。赤いトゲはダメージ。カメラはスムーズ追従で急なジャンプなし。</div>
  </div>

<script>
(() => {
  // ====== エラーハンドラ（画面に表示） ======
  window.addEventListener('error', (e) => {
    const el = document.getElementById('msg');
    el.textContent = 'エラー: ' + e.message;
  });

  // ====== 基本パラメータ ======
  const TILE = 32;               // タイルpx
  const CHUNK_W = 32;            // 1チャンクの横タイル数（無限生成の単位）
  const MAX_Y = 64;              // 想定する縦方向の最大タイル（地盤用）

  // タイル記号
  const EMPTY='.'; const SOLID='#'; const ITEM='*'; const FLAG='F'; const SPIKE='^';

  // ====== 画面 ======
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  if (!ctx) { document.getElementById('msg').textContent = 'Canvasが使えません'; return; }

  // ====== 入力 ======
  const keys = new Set();
  window.addEventListener('keydown', e => { keys.add(e.key.toLowerCase()); if(['arrowleft','arrowright',' '].includes(e.key.toLowerCase())) e.preventDefault(); });
  window.addEventListener('keyup', e => keys.delete(e.key.toLowerCase()));
  const any = (...arr) => arr.some(k => keys.has(k.toLowerCase()));

  // ====== 便利関数 ======
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a,b,t) => a + (b-a)*t;
  const smooth = t => t*t*(3-2*t);

  // 32-bitハッシュに基づく擬似乱数（列xベースで決定的）
  function hash32(n){ n = Math.imul(n, 0x85ebca6b)>>>0; n ^= n>>>13; n = Math.imul(n, 0xc2b2ae35)>>>0; n ^= n>>>16; return n>>>0; }
  function strHash(s){ let h=0; for(let i=0;i<s.length;i++) h = Math.imul(h ^ s.charCodeAt(i), 2654435761)>>>0; return h>>>0; }
  function rand1(i){ return hash32(i) / 0xFFFFFFFF; }
  function rand2(i, salt){ return hash32(i ^ salt) / 0xFFFFFFFF; }
  const SALT_SPIKE=strHash('spike');
  const SALT_PLAT =strHash('plat');
  const SALT_ITEM =strHash('item');
  const SALT_FLAG =strHash('flag');

  // 1Dバリューノイズ
  function noise1D(x){ const i = Math.floor(x), f = x - i; const a = rand1(i), b = rand1(i+1); return a + (b-a)*smooth(f); }

  // 地形の基準高さ
  function groundHeightAtX(x){
    // 基本レベル + 低周波 + 中周波 の合成（なめらかな起伏）
    let h = 18
      + (noise1D(x*0.17)-0.5)*8
      + (noise1D(x*0.05)-0.5)*6;
    h = Math.floor(clamp(h, 10, 28));
    // スタート付近はフラットでやさしく
    if (x >= -8 && x <= 24) h = 12;
    return h|0;
  }

  // ====== チャンク生成とキャッシュ ======
  const chunks = new Map(); // key=cx -> {ground:[], solids:Set, spikes:Set, items:Set, flags:Set}
  const keyLocal = (dx,y) => dx+","+y;

  function getChunk(cx){
    if (chunks.has(cx)) return chunks.get(cx);
    const ch = { ground: new Array(CHUNK_W), solids: new Set(), spikes: new Set(), items: new Set(), flags: new Set() };

    for (let dx=0; dx<CHUNK_W; dx++){
      const x = cx*CHUNK_W + dx; // 世界x（タイル）
      const gh = groundHeightAtX(x); ch.ground[dx] = gh;

      // スパイク：地面の1つ上に置く（開始付近は出さない）
      if (!(x >= -8 && x <= 12) && rand2(x, SALT_SPIKE) < 0.08){
        ch.spikes.add(keyLocal(dx, gh-1));
      }

      // プラットフォーム：ランダムに開始
      if (rand2(x, SALT_PLAT) < 0.06){
        const w = 2 + Math.floor(rand2(x+13, SALT_PLAT) * 3);      // 2..4
        const dh = 3 + Math.floor(rand2(x+29, SALT_PLAT) * 4);     // 3..6 上に
        const py = Math.max(4, gh - dh);
        for (let i=0; i<w && dx+i<CHUNK_W; i++) ch.solids.add(keyLocal(dx+i, py));
      }

      // アイテム：上空にぽつぽつ
      if (rand2(x, SALT_ITEM) < 0.04){
        const base = ch.solids.has(keyLocal(dx, gh-3)) ? gh-4 : gh-3;
        const iy = Math.max(3, base);
        ch.items.add(keyLocal(dx, iy));
      }
    }

    // 旗：各チャンクに1つ程度（チェックポイント用）
    const flagDx = 4 + Math.floor(rand2(cx, SALT_FLAG) * (CHUNK_W-8));
    const fgh = ch.ground[flagDx];
    ch.flags.add(keyLocal(flagDx, Math.max(3, fgh-1)));

    chunks.set(cx, ch); return ch;
  }

  // ====== タイル問い合わせ ======
  function toLocal(tx){ const cx = Math.floor(tx/CHUNK_W); let dx = tx - cx*CHUNK_W; if (dx < 0) dx += CHUNK_W; return {cx, dx}; }

  function tileAt(tx, ty){
    if (ty >= MAX_Y) return SOLID;                 // 最下層は地盤
    const {cx, dx} = toLocal(tx);
    const ch = getChunk(cx);
    const gh = ch.ground[dx];
    if (ty >= gh) return SOLID;                    // 地面より下は全部ソリッド
    const k = keyLocal(dx, ty);
    if (ch.spikes.has(k)) return SPIKE;
    if (ch.flags.has(k)) return FLAG;
    if (ch.items.has(k)) return ITEM;
    if (ch.solids.has(k)) return SOLID;
    return EMPTY;
  }

  // ====== ゲーム状態 ======
  const state = {
    hp: 3,
    inv: 0,
    score: 0,
    maxDist: 0,
    spawn: { x: TILE*3, y: TILE*9 },
    msg: '★を集めて進もう！ 旗でチェックポイント。',
    msgTimer: 220,
  };

  const player = { x: state.spawn.x, y: state.spawn.y, w: 26, h: 28, vx: 0, vy: 0, onGround: false, facing: 1 };

  // ====== 衝突 ======
  function collideX(){
    const left = Math.floor((player.x - player.w/2) / TILE);
    const right = Math.floor((player.x + player.w/2) / TILE);
    const top = Math.floor((player.y - player.h/2) / TILE);
    const bottom = Math.floor((player.y + player.h/2) / TILE);

    if (player.vx > 0){
      const nx = Math.floor((player.x + player.w/2 + player.vx) / TILE);
      for (let ty=top; ty<=bottom; ty++) if (tileAt(nx, ty) === SOLID){
        player.x = nx * TILE - player.w/2 - 0.01; player.vx = 0; break;
      }
    } else if (player.vx < 0){
      const nx = Math.floor((player.x - player.w/2 + player.vx) / TILE);
      for (let ty=top; ty<=bottom; ty++) if (tileAt(nx, ty) === SOLID){
        player.x = (nx+1) * TILE + player.w/2 + 0.01; player.vx = 0; break;
      }
    }
  }

  function collideY(){
    const left = Math.floor((player.x - player.w/2) / TILE);
    const right = Math.floor((player.x + player.w/2) / TILE);

    if (player.vy > 0){
      const ny = Math.floor((player.y + player.h/2 + player.vy) / TILE);
      for (let tx=left; tx<=right; tx++) if (tileAt(tx, ny) === SOLID){
        player.y = ny * TILE - player.h/2 - 0.01; player.vy = 0; player.onGround = true; return;
      }
    } else if (player.vy < 0){
      const ny = Math.floor((player.y - player.h/2 + player.vy) / TILE);
      for (let tx=left; tx<=right; tx++) if (tileAt(tx, ny) === SOLID){
        player.y = (ny+1) * TILE + player.h/2 + 0.01; player.vy = 0; return;
      }
    }
    player.onGround = false;
  }

  function overlapTiles(cb){
    const l = Math.floor((player.x - player.w/2) / TILE);
    const r = Math.floor((player.x + player.w/2) / TILE);
    const t = Math.floor((player.y - player.h/2) / TILE);
    const b = Math.floor((player.y + player.h/2) / TILE);
    for (let ty=t; ty<=b; ty++) for (let tx=l; tx<=r; tx++) cb(tx,ty,tileAt(tx,ty));
  }

  function removeItemAt(tx,ty){
    const {cx, dx} = toLocal(tx); const ch = getChunk(cx); ch.items.delete(keyLocal(dx,ty));
  }

  function isSpikeTile(t){ return t===SPIKE; }
  function isItemTile(t){ return t===ITEM; }
  function isFlagTile(t){ return t===FLAG; }

  // ====== ダメージ/リスポーン ======
  function takeDamage(){
    if (state.inv > 0) return;
    state.hp = Math.max(0, state.hp - 1); state.inv = 60;
    player.vy = -7; player.vx += (player.facing>0 ? -3.5 : 3.5);
    showMsg('ダメージ！', 40);
    if (state.hp <= 0) respawn();
  }

  function respawn(){
    player.x = state.spawn.x; player.y = state.spawn.y; player.vx = 0; player.vy = 0; state.hp = 3; state.inv = 40; showMsg('リスポーン', 60);
  }

  // ====== カメラ ======
  const cam = { x:0, y:0 };
  function updateCamera(){
    const targetX = Math.max(0, player.x - W/2);
    const targetY = Math.max(0, player.y - H/2);
    cam.x = lerp(cam.x, targetX, 0.12);
    cam.y = lerp(cam.y, targetY, 0.12);
  }

  // ====== 描画 ======
  let tick = 0, last = 0;

  function drawTile(x, y, t){
    const px = x*TILE - cam.x, py = y*TILE - cam.y;
    if (t === SOLID){
      ctx.fillStyle = '#1b2446'; ctx.fillRect(px, py, TILE, TILE);
      ctx.fillStyle = '#28315f'; ctx.fillRect(px+2, py+2, TILE-4, TILE-8);
      ctx.fillStyle = '#101735'; ctx.fillRect(px+2, py+TILE-6, TILE-4, 4);
    } else if (t === SPIKE){
      ctx.fillStyle = '#210b0b'; ctx.fillRect(px, py, TILE, TILE);
      ctx.fillStyle = '#ef4444'; ctx.beginPath(); ctx.moveTo(px, py+TILE); ctx.lineTo(px+TILE/2, py+4); ctx.lineTo(px+TILE, py+TILE); ctx.closePath(); ctx.fill();
    } else if (t === ITEM){
      const cx = px + TILE/2, cy = py + TILE/2; const r = 6 + Math.sin(tick/10)*2;
      const grad = ctx.createRadialGradient(cx, cy, 2, cx, cy, 14);
      grad.addColorStop(0, '#7dd3fc'); grad.addColorStop(1, 'rgba(125,211,252,0)');
      ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(cx, cy, 14, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#93c5fd'; ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();
    } else if (t === FLAG){
      ctx.fillStyle = '#2d3a6a'; ctx.fillRect(px+14, py+2, 2, TILE-4);
      ctx.fillStyle = '#a78bfa'; ctx.beginPath(); ctx.moveTo(px+16, py+6); ctx.lineTo(px+28, py+10); ctx.lineTo(px+16, py+14); ctx.closePath(); ctx.fill();
    }
  }

  function showMsg(text, t=120){ state.msg = text; state.msgTimer = t; }
  function drawMsg(){ const el = document.getElementById('msg'); if (state.msgTimer>0){ el.textContent = state.msg; state.msgTimer--; } else el.textContent=''; }
  function updateHUD(){
    const hpEl = document.getElementById('hp'); if (hpEl) hpEl.textContent = 'HP: ' + '❤'.repeat(state.hp);
    const scEl = document.getElementById('score'); if (scEl) scEl.textContent = '★ ' + state.score;
    const dEl = document.getElementById('dist'); if (dEl) dEl.textContent = '距離: ' + Math.max(0, state.maxDist) + 'm';
  }

  // ====== ループ ======
  function loop(ts){
    const dt = Math.min(33, ts - last); last = ts; tick++;

    // 入力
    const L = any('arrowleft','a'); const R = any('arrowright','d'); const JUMP = any('z',' ');

    // 水平移動
    const accel = 0.45, maxVx = 3.0, friction = 0.82;
    if (L) { player.vx -= accel; player.facing = -1; }
    if (R) { player.vx += accel; player.facing = 1; }
    if (!L && !R) player.vx *= friction;
    player.vx = clamp(player.vx, -maxVx, maxVx);

    // 重力/ジャンプ
    const g = 0.55, jumpV = -9.0, maxVy = 12;
    player.vy += g; player.vy = Math.min(player.vy, maxVy);
    if (JUMP && player.onGround) { player.vy = jumpV; player.onGround = false; }

    // 物理＆衝突
    player.x += player.vx; collideX();
    player.y += player.vy; collideY();

    // タイル効果
    overlapTiles((tx,ty,t) => {
      if (isSpikeTile(t)) takeDamage();
      if (isFlagTile(t)) { state.spawn.x = tx*TILE + TILE/2; state.spawn.y = ty*TILE; }
      if (isItemTile(t)) { removeItemAt(tx,ty); state.score += 1; }
    });

    if (keys.has('r')) { respawn(); keys.delete('r'); }
    if (state.inv > 0) state.inv--;

    // 記録距離
    state.maxDist = Math.max(state.maxDist, Math.floor(player.x / TILE));

    // カメラ
    updateCamera();

    // 背景
    ctx.clearRect(0,0,W,H);
    const bg = ctx.createLinearGradient(0,0,0,H); bg.addColorStop(0,'#081127'); bg.addColorStop(1,'#0c1021'); ctx.fillStyle = bg; ctx.fillRect(0,0,W,H);

    // 可視範囲タイル描画
    const x0 = Math.floor(cam.x / TILE) - 1, y0 = Math.floor(cam.y / TILE) - 1;
    const x1 = Math.ceil((cam.x + W) / TILE) + 1, y1 = Math.ceil((cam.y + H) / TILE) + 1;
    for (let y=y0; y<y1; y++){
      for (let x=x0; x<x1; x++){
        const t = tileAt(x,y);
        if (t !== EMPTY) drawTile(x,y,t);
      }
    }

    // プレイヤー
    const px = Math.round(player.x - cam.x), py = Math.round(player.y - cam.y);
    ctx.fillStyle = 'rgba(0,0,0,.25)'; ctx.fillRect(px-12, py+player.h/2-2, 24, 4);
    ctx.fillStyle = state.inv>0 && (Math.floor(tick/4)%2===0) ? 'rgba(229,231,235,.5)' : '#e5e7eb';
    ctx.fillRect(px - player.w/2, py - player.h/2, player.w, player.h);
    ctx.fillStyle = '#111827'; const eyeX = px + (player.facing>0?4:-8), eyeY = py - 6; ctx.fillRect(eyeX, eyeY, 4, 4);

    updateHUD(); drawMsg();
    requestAnimationFrame(loop);
  }

  // 初期化
  updateHUD(); requestAnimationFrame(loop);
})();
</script>
</body>
</html>
